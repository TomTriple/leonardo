describe("Turtle Lexer", function() {

  // beware: this token definitions are generated by "make update"
  // If you want to regenerate them use as right hand side of T '@@TT@@'
  var T = { DEF_EMPTY_BLANK: 4, DEF_TRIPLES: 5, DEF_COLLECTION: 6, DEF_BNPL: 7, WS: 8, DOT: 9, PREFIX: 10, PNAME_NS: 11, IRIREF: 12, BASE: 13, SEMI: 14, A: 15, COMMA: 16, PAREN_ROUND_OPEN: 17, PAREN_ROUND_CLOSE: 18, BLANK_NODE_LABEL: 19, PAREN_BRACKETS_OPEN: 20, PAREN_BRACKETS_CLOSE: 21, TRUE: 22, FALSE: 23, INTEGER: 24, DECIMAL: 25, DOUBLE: 26, LANGTAG: 27, EYES: 28, STRING_LITERAL_QUOTE: 29, STRING_LITERAL_SINGLE_QUOTE: 30, STRING_LITERAL_LONG_SINGLE_QUOTE: 31, STRING_LITERAL_LONG_QUOTE: 32, PNAME_LN: 33, UCHAR: 34, PN_PREFIX: 35, PN_LOCAL: 36, ECHAR: 37, PN_CHARS_U: 38, PN_CHARS: 39, EXPONENT: 40, COMMENT: 41, PLX: 42, PERCENT: 43, PN_LOCAL_ESC: 44, HEX: 45, PN_CHARS_BASE: 46,   };

  var newStream = function(input) {
    return new org.antlr.runtime.ANTLRStringStream(input);
  }
  var newLexer = function(stream) {
    return new ASTBuildingTurtleLexer(stream);
  }
  var useInput = function(input) {
    stream = newStream(input);
    lexer = newLexer(stream);
  }

  // That function performs a mapping from internal ID
  // to the name of a token
  var int2name = function(intValue) {
    for (var prop in T) {
      if(T[prop] === intValue) 
        return prop;
    }
  }

  // Returns the type of the next token
  var nextTT = function() {
    var t = lexer.nextToken();
    console.log(t.getText() + " \t " + int2name(t.getType()));
    return t.getType();
  }

  // Compares the items in 'expectations', which are token types, with 
  // the token types from the input.
  var expectSeq = function(expectations) {
    var type = nextTT();
    for(var i = 0; i < expectations.length; i++, type = nextTT()) {
      expect(type).toEqual(expectations[i]);
    }
    // ensure that nothing remains silently in the input stream
    expect(nextTT()).toEqual(-1);
  }

  // That function supports arguments variable length. The first argument
  // is the input code whereas the remaining arguments are the expected
  // tokens which should result from the input code. 
  var _ = function() {
    useInput(arguments[0]);
    expectSeq(Array.prototype.slice.apply(arguments, [1]));
  }

  // A debugging function
  var inspectTokens = function(tokens) {
    useInput(tokens);
    while(nextTT() != -1) {
      ;
    }
  }

   
  var stream, lexer;

  //var tstream = new org.antlr.runtime.CommonTokenStream(lexer),
  //var parser = new TurtleParser(tstream),
  //var r = parser.turtleDoc();

  beforeEach(function() {
    input = "";
    stream = lexer = undefined;
  });


  it("should recognize different kinds of <IRIREF> tokens", function() {
    _("<\\u8888\\uffFF> ", T.IRIREF);
    _("<http://www.example.org/test-resource>", T.IRIREF);
    _("<http://www.example.org/test-\\u8888\\uffFF-resource>", T.IRIREF);
  });

  it("should recognize entire <base> rules", function() {
    _("@base <http://one.example/> .", T.BASE, T.WS, T.IRIREF, T.WS, T.DOT);
  });

  it("should recognize entire <prefixID> rules", function() {
    _("@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .", T.PREFIX, T.WS, T.PNAME_NS, T.WS, T.IRIREF, T.WS, T.DOT);
    _("@prefix : <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .", T.PREFIX, T.WS, T.PNAME_NS, T.WS, T.IRIREF, T.WS, T.DOT);
  });

  it("should recognize entire <triples> rules", function() {
    _("<http://subject.google.de> <http://predicate.google.de> <http://object.google.de> . ", T.IRIREF, T.WS, T.IRIREF, T.WS, T.IRIREF, T.WS, T.DOT);
    _(
      "<http://subject2.google.de> <http://predicate2.google.de> <http://object2.google.de> ; <http://x.google.de> <http://y.google.de> , <http://z.google.de> . ", 
      T.IRIREF, T.WS, T.IRIREF, T.WS, T.IRIREF, T.WS, T.SEMI, T.WS, T.IRIREF, T.WS, T.IRIREF, T.WS, T.COMMA, T.WS, T.IRIREF, T.WS, T.DOT
     );
    _("<#green-goblin> rel:enemyOf <#spiderman> ; a foaf:Person ; foaf:name <#vorname> , <#nachname> . ", 
      T.IRIREF, T.WS, T.PNAME_LN, T.WS, T.IRIREF, T.WS, T.SEMI, T.WS, T.A, T.WS, T.PNAME_LN, T.WS, T.SEMI, T.WS, T.PNAME_LN, T.WS, T.IRIREF, T.WS, T.COMMA, T.WS, T.IRIREF, T.WS, T.DOT
     );
  });

  it("should recognize different kinds of <string> rules", function() {
    _("<#green-goblin> rel:enemyOf \"Spiderman\" . ", T.IRIREF, T.WS, T.PNAME_LN, T.WS, T.STRING_LITERAL_QUOTE, T.WS, T.DOT);
    _("<#green-goblin> rel:enemyOf \"Spidey\"@en-us . ", T.IRIREF, T.WS, T.PNAME_LN, T.WS, T.STRING_LITERAL_QUOTE, T.LANGTAG, T.WS, T.DOT);
    _("<#green-goblin> rel:enemyOf \"Spiderman\"@en . ", T.IRIREF, T.WS, T.PNAME_LN, T.WS, T.STRING_LITERAL_QUOTE, T.LANGTAG, T.WS, T.DOT);
    _("<#green-goblin> rel:enemyOf \"Spiderman\"^^xsd:string . ",T.IRIREF, T.WS, T.PNAME_LN, T.WS, T.STRING_LITERAL_QUOTE, T.EYES, T.PNAME_LN, T.WS, T.DOT);
    _("<#green-goblin> rel:enemyOf 'Spiderman' . ", T.IRIREF, T.WS, T.PNAME_LN, T.WS, T.STRING_LITERAL_SINGLE_QUOTE, T.WS, T.DOT);
    _("<#green-goblin> <http://www.enemies.de/vocabs/enemyOf> 'Spiderman'@en-us . ",T.IRIREF, T.WS, T.IRIREF, T.WS, T.STRING_LITERAL_SINGLE_QUOTE, T.LANGTAG, T.WS, T.DOT);
    _(":a :b ''' \\r\\rHallo das ist ein \\r\\r     test ''' . ", T.PNAME_LN, T.WS, T.PNAME_LN, T.WS, T.STRING_LITERAL_LONG_SINGLE_QUOTE, T.WS, T.DOT);
    _(":a :b ''' \\n\\t \"ganz wichtig\" ebenso: 'auch wichtig'    test '''@de-at . ", T.PNAME_LN, T.WS, T.PNAME_LN, T.WS, T.STRING_LITERAL_LONG_SINGLE_QUOTE, T.LANGTAG, T.WS, T.DOT);
    _(":a :b \"\"\" \\n\\t \"ganz wichtig\" ebenso: 'auch wichtig'    test \"\"\"@de-at . ", T.PNAME_LN, T.WS, T.PNAME_LN, T.WS, T.STRING_LITERAL_LONG_QUOTE, T.LANGTAG, T.WS, T.DOT);

  });

  it("should recognize different kinds of <numericLiteral> rules", function(){
    _(":a :b 10 . :c :d 12.23 . :e :f 14074.2E9 . :g :h .0135 . ", 
      T.PNAME_LN, T.WS, T.PNAME_LN, T.WS, T.INTEGER, T.WS, T.DOT, T.WS,
      T.PNAME_LN, T.WS, T.PNAME_LN, T.WS, T.DECIMAL, T.WS, T.DOT, T.WS,
      T.PNAME_LN, T.WS, T.PNAME_LN, T.WS, T.DOUBLE, T.WS, T.DOT, T.WS,
      T.PNAME_LN, T.WS, T.PNAME_LN, T.WS, T.DECIMAL, T.WS, T.DOT
     );
  });

  it("should recognize different kinds of <booleanLiteral> rules", function() {
    _(":a :b true ; :c false . ", 
      T.PNAME_LN, T.WS, T.PNAME_LN, T.WS, T.TRUE, T.WS, T.SEMI, T.WS, 
      T.PNAME_LN, T.WS, T.FALSE, T.WS, T.DOT
     );
  });

  it("should recognize some blank node stuff", function() {
    _(':a :b [ ex:fullname "Dave Becket" ; ex:homePage <http://purl.org/net/dajobe/> ] . ', 
      T.PNAME_LN, T.WS, T.PNAME_LN, T.WS, T.PAREN_BRACKETS_OPEN, T.WS, 
      T.PNAME_LN, T.WS, T.STRING_LITERAL_QUOTE, T.WS, T.SEMI, T.WS, 
      T.PNAME_LN, T.WS, T.IRIREF, T.WS, T.PAREN_BRACKETS_CLOSE, T.WS, T.DOT
    );
  });

  it("should recognize different kinds of <collection> rules", function() {
    _(":subject :predicate ( :a :b :c ) . ", T.PNAME_LN, T.WS, T.PNAME_LN, T.WS, 
      T.PAREN_ROUND_OPEN, T.WS, T.PNAME_LN, T.WS, T.PNAME_LN, T.WS, T.PNAME_LN, T.WS, T.PAREN_ROUND_CLOSE, T.WS, T.DOT
     );

    _(":subject :predicate2 () . ", T.PNAME_LN, T.WS, T.PNAME_LN, T.WS, T.PAREN_ROUND_OPEN, T.PAREN_ROUND_CLOSE, T.WS, T.DOT);
  });


})


